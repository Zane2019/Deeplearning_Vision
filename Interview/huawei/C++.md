C++知识总结


知识盲区：
C++中，类的对象建立分两种，一种是静态建立，如A a;另一种是动态建立，如A* Ptr=new A;
静态建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存空间调用构造函数形成一个栈对象。
动态建立，是使用new运算符将对象建立在堆空间中，这个过程分两部，第一步是执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间，这种方法间接调用类的构造函数。
- 只能在堆上建立的对象
  当对象建立在栈上面是，是由编译器分配内存空间的，调用构造函数来构造对象，当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，类的析构函数是私有的，编译器无法调用析构函数来释放内存。所以，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。因此，将析构函数设为私有，类对象就无法建立在栈上了。
  但是把析构函数设置为private，将导致继承问题，由于析构函数通常要设为virtual，然后在子类重写，以实现多态。如果设为private将使得子类不能重写。因此将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问。
- 只能在栈上建立的对象
  只有使用new 运算符，对象才会建立在堆上，因此只要禁用new运算符就可以实现类对象只能建立在栈上。即将operator new()设为私有即可。代码如下：
  ```cpp
  class A{
      private:
        void* operator new(size_t t) {} //注意函数的第一个参数和返回值是固定的
        void operator delete(void* p) {} //重载了new 就需要重载delete
  }
  ```

#### 1.如何实现一个只能在堆上建立实例的类
#### 2.基于接口的编程内容及优点
在程序架构的设计过程中，前辈们总结出了一系列程序设计的原则，其中有一条就是 - 依赖倒置原则：高层模块不应该依赖于底层模块，二者都应该依赖于抽象；抽象不应该细节，细节应该依赖于抽象。
上面提到的抽象就是指的抽象接口
.接口编程在设计模式中的体现：开闭原则(对扩展开放，对修改封闭)
面向接口编程就是先把客户的业务逻辑线提取出来，作为接口，业务具体实现通过该接口的实现类来完成。
当客户需求变化时，只需编写该业务逻辑的新的实现类，通过更改配置文件(例如Spring框架)中该接口的实现类就可以完成需求，不需要改写现有代码，减少对系统的影响。。
**1 降低程序的耦合性;2 易于程序的扩展；3 有利于程序的维护；。**
#### 3.多态
为了实现C++的多态，C++使用了一种动态绑定的技术。这个技术的核心是虚函数表。

#### 4.内联函数
内联函数，将频繁使用的函数定义为内联函数有什么弊端?会造成汇编代码重复过多，代码冗长.
引入内联函数的目的是**为了解决程序中函数调用的效率问题**，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省.

注意:**关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用**
#### 5.为什么inline函数应该在头文件中定义？
inline函数（即内联函数）对编译器而言必须是可见的，以便能够在调用点展开该函数，与非inline函数不同的是，inline函数必须在调用该函数的每个文件中定义。当然，对于同一程序的不同文件，如果inline函数出现的话，其定义必须相同.正因为如此，建议把inline函数的定义放到头文件中，在每个调用该inline函数的文件中包含该头文件。这种方法保证了每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命周期中引起无意的不匹配的事情。
#### 6.C++内存分区,重复释放同一块内存后果

务必保证被分配的内存块被且仅被释放一次，保证已经被释放了的指针不会再次被调用。如果这个指针曾经被复制过，就必须保证当它所指向的内存区域被释放后，所有的拷贝都不应当被使用
#### 7.
如果不再使用已分配的内存却没有将其释放就会发生内存泄露，导致内存泄露的主要情况可能如下
- 丢失内存地址
- 应该调用delete函数却没有调用（隐式泄露）
丢失内存地址举例
```cpp
int *pi = new int(5);

pi = new int(10);
```
在第一次new申请一个堆的时候，操作系统分配了一个内存地址给我们，并且赋值给了指针pi,我们往这个地址中写入了数据（int 5）。后续申请一个堆，覆盖了之前申请的地址，指向5的内存地址的值就丢失了，但是int 5 占用的内存空间并没有释放掉。

#### 8. Map键的无重复性是怎么实现的，如果想要自定义比较如何实现

#### 9.二叉树两个节点最长距离

#### 10.btree b+tree

#### 11.双向链表 create delete 写出一个就可以 不能调库

#### 12.死锁

产生死锁的的原因有:
系统资源不足,进程运行推进的顺序不合适,资源分配不当等.
产生死锁的四个必要条件:
互斥条件:一个资源每次只能被一个进程使用
请求与保持条件:一个进程因请求资源而阻塞时,对已获得的资源保持不放.
不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺
循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系.


死锁的解除与预防:
在系统设计,进程调度等方面注意如何不让这四个必要天剑成立,如何确定资源的合理分配算法,避免进程永久占据系统资源.此外也要防止进程在处于等待状态下占用资源.
